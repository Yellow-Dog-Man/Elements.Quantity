using System;

namespace Elements.Quantity
{
    public readonly struct QuantityName : IQuantitySI<QuantityName>
    {
        #region ESSENTIALS

        // this section can be simply left as is, but rename QuantityName

        public readonly double BaseValue;

        double IQuantity.BaseValue => BaseValue;

        public QuantityName(double baseValue = 0) : this() { BaseValue = baseValue; }

        public bool Equals(QuantityName other) { return BaseValue == other.BaseValue; }
        public int CompareTo(QuantityName other) { return BaseValue.CompareTo(other.BaseValue); }

        #endregion

        /* *********************************************** */

        #region QUANTITY NAME DEFINITIONS

        // Provide at least one short and one long name for the quantity
        // The first entry will be used for formatting, all will be used for parsing

        public string[] GetShortBaseNames() { return new string[] { "" }; }
        public string[] GetLongBaseNames()
        { return new string[] { "" }; }

        #endregion

        /* *********************************************** */

        #region SI UNIT DEFINITIONS

        // the SI factor will be adjusted for this
        public double SIPower { get { return 1; } }

        // these units will be automatically registered in the Common groups
        public IUnit[] GetCommonSIUnits()
        {
            return new IUnit[] {
            };
        }

        // these SI units will never be used for formatting, unless used explicitly
        public IUnit[] GetExludedSIUnits()
        {
            return new IUnit[] {
            };
        }

        #endregion

        /* *********************************************** */

        #region UNITS

        // provide a default unit for the quantity - used when no explicit unit specified
        public Unit<QuantityName> DefaultUnit { get {  } }

        // define actual units for the quantity (excluding SI units which are automatic)
        // Parameters:

        public static readonly Unit<QuantityName> BaseUnit = new UnitSI<QuantityName>(0, "", "");

        public static readonly Unit<QuantityName> SomeUnit = new Unit<QuantityName>(1,
            new UnitGroup[] { UnitGroup.Common },
            new string[] { " u" }, new string[] { " units" });

        #endregion

        /* *********************************************** */

        #region COMPOUND FORMATING TEMPLATES

        // define any commonly used compound formating templates

        public static readonly CompoundFormatInfo<QuantityName> FormatingTemplate =
            new CompoundFormatInfo<QuantityName>(null, null, CompoundZeroHandling.RemoveAny, false,
            new CompoundFormatInfo<QuantityName>.Info(SomeUnit),
            );

        #endregion

        /* *********************************************** */

        #region OPERATORS

        public QuantityName New(double baseVal) { return new QuantityName(baseVal); }

        public QuantityName Min(QuantityName q) { return new QuantityName(Math.Min(BaseValue, q.BaseValue)); }
        public QuantityName Max(QuantityName q) { return new QuantityName(Math.Max(BaseValue, q.BaseValue)); }

        public QuantityName Add(QuantityName q) { return new QuantityName(BaseValue + q.BaseValue); }
        public QuantityName Subtract(QuantityName q) { return new QuantityName(BaseValue - q.BaseValue); }

        public QuantityName Multiply(double n) { return new QuantityName(BaseValue * n); }
        public QuantityName Multiply(QuantityName a, Ratio r) { return a * r.BaseValue; }
        public QuantityName Multiply(Ratio r, QuantityName a) { return a * r.BaseValue; }

        public QuantityName Divide(double n) { return new QuantityName(BaseValue / n); }
        public Ratio Divide(QuantityName q) { return new Ratio(BaseValue / q.BaseValue); }

        public QuantityName Lerp(QuantityName q, double lerp) {
            if (lerp <= 0.0)
		    {
			    return this;
		    }
		    if (lerp >= 1.0)
		    {
			    return q;
		    }
            return LerpUnclamped(q, lerp);
        }
        public QuantityName LerpUnclamped(QuantityName q, double lerp) { return new QuantityName(BaseValue + (q.BaseValue - BaseValue) * lerp); }

        // these should be defined as convenience, but cannot be forced by interface
        public static QuantityName Parse(string str) { return Unit<QuantityName>.Parse(str); }
        public static bool TryParse(string str, out QuantityName q) { return Unit<QuantityName>.TryParse(str, out q); }

        public static QuantityName operator +(QuantityName a, QuantityName b) { return a.Add(b); }
        public static QuantityName operator -(QuantityName a, QuantityName b) { return a.Subtract(b); }
        public static QuantityName operator *(QuantityName a, double n) { return a.Multiply(n); }
        public static QuantityName operator /(QuantityName a, double n) { return a.Divide(n); }
        public static Ratio operator /(QuantityName a, QuantityName b) { return a.Divide(b); }
        public static QuantityName operator -(QuantityName a) { return a.Multiply(-1); }

        #endregion

        /* *********************************************** */

        #region CONVERSIONS

        // provide various operators to convert between quantities or adjust the quantity

        #endregion

        /* *********************************************** */
    }
}
